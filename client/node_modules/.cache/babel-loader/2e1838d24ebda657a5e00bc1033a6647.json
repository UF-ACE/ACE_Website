{"ast":null,"code":"//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n'use strict';\n\nvar forEach = require('array.prototype.foreach');\n\nvar entries = require('object.entries');\n\nvar warning = require('warning');\n\nvar has = require('has');\n\nvar trim = require('string.prototype.trim');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar replace = String.prototype.replace;\nvar split = String.prototype.split; // #### Pluralization methods\n// The string that separates the different phrase possibilities.\n\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) {\n        return n;\n      }\n\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () {\n      return 0;\n    },\n    croatian: russianPluralGroups,\n    french: function (n) {\n      return n >= 2 ? 1 : 0;\n    },\n    german: function (n) {\n      return n !== 1 ? 1 : 0;\n    },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) {\n        return 0;\n      }\n\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n\n      return n >= 2 && n <= 4 ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) {\n        return 0;\n      }\n\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) {\n      return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;\n    },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n\n      if (lastTwo === 1) {\n        return 0;\n      }\n\n      if (lastTwo === 2) {\n        return 1;\n      }\n\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n\n      return 3;\n    }\n  },\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is'],\n    slovenian: ['sl-SL']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  forEach(entries(mapping), function (entry) {\n    var type = entry[0];\n    var langs = entry[1];\n    forEach(langs, function (lang) {\n      ret[lang] = type;\n    });\n  });\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale] || langToPluralType[split.call(locale, /-/, 1)[0]] || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\n\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n\n    return pluralType;\n  };\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = opts && opts.prefix || '%{';\n  var suffix = opts && opts.suffix || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\nvar defaultTokenRegex = /%\\{(.*?)\\}/g; // ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\n\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex; // allow number as a pluralization shortcut\n\n  var options = typeof substitutions === 'number' ? {\n    smart_count: substitutions\n  } : substitutions; // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(pluralRulesOrDefault, pluralType, options.smart_count);\n    result = trim(texts[pluralTypeWithCount] || texts[0]);\n  } // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n\n\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) {\n      return expression;\n    }\n\n    return options[argument];\n  });\n  return result;\n} // ### Polyglot class constructor\n\n\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n} // ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\n\n\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n}; // ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\n\n\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  forEach(entries(morePhrases || {}), function (entry) {\n    var key = entry[0];\n    var phrase = entry[1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }, this);\n}; // ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\n\n\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    forEach(entries(morePhrases || {}), function (entry) {\n      var key = entry[0];\n      var phrase = entry[1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }, this);\n  }\n}; // ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\n\n\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n}; // ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\n\n\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n}; // ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\n\n\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  }\n\n  return result;\n}; // ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\n\n\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n}; // export transformPhrase\n\n\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;","map":{"version":3,"sources":["/Users/cameronkeene/Documents/GitHub/ACE_Website/client/node_modules/node-polyglot/index.js"],"names":["forEach","require","entries","warning","has","trim","warn","message","replace","String","prototype","split","delimiter","russianPluralGroups","n","lastTwo","end","defaultPluralRules","pluralTypes","arabic","bosnian_serbian","chinese","croatian","french","german","russian","lithuanian","czech","polish","icelandic","slovenian","pluralTypeToLanguages","langToTypeMap","mapping","ret","entry","type","langs","lang","pluralTypeName","pluralRules","locale","langToPluralType","call","en","pluralTypeIndex","pluralType","count","createMemoizedPluralTypeNameSelector","localePluralTypeStorage","escape","token","constructTokenRegex","opts","prefix","suffix","RangeError","RegExp","memoizedPluralTypeName","defaultTokenRegex","transformPhrase","phrase","substitutions","tokenRegex","TypeError","result","interpolationRegex","options","smart_count","pluralRulesOrDefault","texts","bestLocale","pluralTypeWithCount","expression","argument","Polyglot","phrases","extend","currentLocale","allowMissing","onMissingKey","interpolation","newLocale","morePhrases","key","prefixedKey","unset","clear","newPhrases","t","_","transform","module","exports"],"mappings":"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","sourcesContent":["//     (c) 2012-2018 Airbnb, Inc.\n//\n//     polyglot.js may be freely distributed under the terms of the BSD\n//     license. For all licensing information, details, and documentation:\n//     http://airbnb.github.com/polyglot.js\n//\n//\n// Polyglot.js is an I18n helper library written in JavaScript, made to\n// work both in the browser and in Node. It provides a simple solution for\n// interpolation and pluralization, based off of Airbnb's\n// experience adding I18n functionality to its Backbone.js and Node apps.\n//\n// Polylglot is agnostic to your translation backend. It doesn't perform any\n// translation; it simply gives you a way to manage translated phrases from\n// your client- or server-side JavaScript application.\n//\n\n'use strict';\n\nvar forEach = require('array.prototype.foreach');\nvar entries = require('object.entries');\nvar warning = require('warning');\nvar has = require('has');\nvar trim = require('string.prototype.trim');\n\nvar warn = function warn(message) {\n  warning(false, message);\n};\n\nvar replace = String.prototype.replace;\nvar split = String.prototype.split;\n\n// #### Pluralization methods\n// The string that separates the different phrase possibilities.\nvar delimiter = '||||';\n\nvar russianPluralGroups = function (n) {\n  var lastTwo = n % 100;\n  var end = lastTwo % 10;\n  if (lastTwo !== 11 && end === 1) {\n    return 0;\n  }\n  if (2 <= end && end <= 4 && !(lastTwo >= 12 && lastTwo <= 14)) {\n    return 1;\n  }\n  return 2;\n};\n\nvar defaultPluralRules = {\n  // Mapping from pluralization group plural logic.\n  pluralTypes: {\n    arabic: function (n) {\n      // http://www.arabeyes.org/Plural_Forms\n      if (n < 3) { return n; }\n      var lastTwo = n % 100;\n      if (lastTwo >= 3 && lastTwo <= 10) return 3;\n      return lastTwo >= 11 ? 4 : 5;\n    },\n    bosnian_serbian: russianPluralGroups,\n    chinese: function () { return 0; },\n    croatian: russianPluralGroups,\n    french: function (n) { return n >= 2 ? 1 : 0; },\n    german: function (n) { return n !== 1 ? 1 : 0; },\n    russian: russianPluralGroups,\n    lithuanian: function (n) {\n      if (n % 10 === 1 && n % 100 !== 11) { return 0; }\n      return n % 10 >= 2 && n % 10 <= 9 && (n % 100 < 11 || n % 100 > 19) ? 1 : 2;\n    },\n    czech: function (n) {\n      if (n === 1) { return 0; }\n      return (n >= 2 && n <= 4) ? 1 : 2;\n    },\n    polish: function (n) {\n      if (n === 1) { return 0; }\n      var end = n % 10;\n      return 2 <= end && end <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n    },\n    icelandic: function (n) { return (n % 10 !== 1 || n % 100 === 11) ? 1 : 0; },\n    slovenian: function (n) {\n      var lastTwo = n % 100;\n      if (lastTwo === 1) {\n        return 0;\n      }\n      if (lastTwo === 2) {\n        return 1;\n      }\n      if (lastTwo === 3 || lastTwo === 4) {\n        return 2;\n      }\n      return 3;\n    }\n  },\n\n  // Mapping from pluralization group to individual language codes/locales.\n  // Will look up based on exact match, if not found and it's a locale will parse the locale\n  // for language code, and if that does not exist will default to 'en'\n  pluralTypeToLanguages: {\n    arabic: ['ar'],\n    bosnian_serbian: ['bs-Latn-BA', 'bs-Cyrl-BA', 'srl-RS', 'sr-RS'],\n    chinese: ['id', 'id-ID', 'ja', 'ko', 'ko-KR', 'lo', 'ms', 'th', 'th-TH', 'zh'],\n    croatian: ['hr', 'hr-HR'],\n    german: ['fa', 'da', 'de', 'en', 'es', 'fi', 'el', 'he', 'hi-IN', 'hu', 'hu-HU', 'it', 'nl', 'no', 'pt', 'sv', 'tr'],\n    french: ['fr', 'tl', 'pt-br'],\n    russian: ['ru', 'ru-RU'],\n    lithuanian: ['lt'],\n    czech: ['cs', 'cs-CZ', 'sk'],\n    polish: ['pl'],\n    icelandic: ['is'],\n    slovenian: ['sl-SL']\n  }\n};\n\nfunction langToTypeMap(mapping) {\n  var ret = {};\n  forEach(entries(mapping), function (entry) {\n    var type = entry[0];\n    var langs = entry[1];\n    forEach(langs, function (lang) {\n      ret[lang] = type;\n    });\n  });\n  return ret;\n}\n\nfunction pluralTypeName(pluralRules, locale) {\n  var langToPluralType = langToTypeMap(pluralRules.pluralTypeToLanguages);\n  return langToPluralType[locale]\n    || langToPluralType[split.call(locale, /-/, 1)[0]]\n    || langToPluralType.en;\n}\n\nfunction pluralTypeIndex(pluralRules, pluralType, count) {\n  return pluralRules.pluralTypes[pluralType](count);\n}\n\nfunction createMemoizedPluralTypeNameSelector() {\n  var localePluralTypeStorage = {};\n\n  return function (pluralRules, locale) {\n    var pluralType = localePluralTypeStorage[locale];\n\n    if (pluralType && !pluralRules.pluralTypes[pluralType]) {\n      pluralType = null;\n      localePluralTypeStorage[locale] = pluralType;\n    }\n\n    if (!pluralType) {\n      pluralType = pluralTypeName(pluralRules, locale);\n\n      if (pluralType) {\n        localePluralTypeStorage[locale] = pluralType;\n      }\n    }\n\n    return pluralType;\n  };\n}\n\nfunction escape(token) {\n  return token.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction constructTokenRegex(opts) {\n  var prefix = (opts && opts.prefix) || '%{';\n  var suffix = (opts && opts.suffix) || '}';\n\n  if (prefix === delimiter || suffix === delimiter) {\n    throw new RangeError('\"' + delimiter + '\" token is reserved for pluralization');\n  }\n\n  return new RegExp(escape(prefix) + '(.*?)' + escape(suffix), 'g');\n}\n\nvar memoizedPluralTypeName = createMemoizedPluralTypeNameSelector();\n\nvar defaultTokenRegex = /%\\{(.*?)\\}/g;\n\n// ### transformPhrase(phrase, substitutions, locale)\n//\n// Takes a phrase string and transforms it by choosing the correct\n// plural form and interpolating it.\n//\n//     transformPhrase('Hello, %{name}!', {name: 'Spike'});\n//     // \"Hello, Spike!\"\n//\n// The correct plural form is selected if substitutions.smart_count\n// is set. You can pass in a number instead of an Object as `substitutions`\n// as a shortcut for `smart_count`.\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 1}, 'en');\n//     // \"1 new message\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', {smart_count: 2}, 'en');\n//     // \"2 new messages\"\n//\n//     transformPhrase('%{smart_count} new messages |||| 1 new message', 5, 'en');\n//     // \"5 new messages\"\n//\n// You should pass in a third argument, the locale, to specify the correct plural type.\n// It defaults to `'en'` with 2 plural forms.\nfunction transformPhrase(phrase, substitutions, locale, tokenRegex, pluralRules) {\n  if (typeof phrase !== 'string') {\n    throw new TypeError('Polyglot.transformPhrase expects argument #1 to be string');\n  }\n\n  if (substitutions == null) {\n    return phrase;\n  }\n\n  var result = phrase;\n  var interpolationRegex = tokenRegex || defaultTokenRegex;\n\n  // allow number as a pluralization shortcut\n  var options = typeof substitutions === 'number' ? { smart_count: substitutions } : substitutions;\n\n  // Select plural form: based on a phrase text that contains `n`\n  // plural forms separated by `delimiter`, a `locale`, and a `substitutions.smart_count`,\n  // choose the correct plural form. This is only done if `count` is set.\n  if (options.smart_count != null && phrase) {\n    var pluralRulesOrDefault = pluralRules || defaultPluralRules;\n    var texts = split.call(phrase, delimiter);\n    var bestLocale = locale || 'en';\n    var pluralType = memoizedPluralTypeName(pluralRulesOrDefault, bestLocale);\n    var pluralTypeWithCount = pluralTypeIndex(\n      pluralRulesOrDefault,\n      pluralType,\n      options.smart_count\n    );\n\n    result = trim(texts[pluralTypeWithCount] || texts[0]);\n  }\n\n  // Interpolate: Creates a `RegExp` object for each interpolation placeholder.\n  result = replace.call(result, interpolationRegex, function (expression, argument) {\n    if (!has(options, argument) || options[argument] == null) { return expression; }\n    return options[argument];\n  });\n\n  return result;\n}\n\n// ### Polyglot class constructor\nfunction Polyglot(options) {\n  var opts = options || {};\n  this.phrases = {};\n  this.extend(opts.phrases || {});\n  this.currentLocale = opts.locale || 'en';\n  var allowMissing = opts.allowMissing ? transformPhrase : null;\n  this.onMissingKey = typeof opts.onMissingKey === 'function' ? opts.onMissingKey : allowMissing;\n  this.warn = opts.warn || warn;\n  this.tokenRegex = constructTokenRegex(opts.interpolation);\n  this.pluralRules = opts.pluralRules || defaultPluralRules;\n}\n\n// ### polyglot.locale([locale])\n//\n// Get or set locale. Internally, Polyglot only uses locale for pluralization.\nPolyglot.prototype.locale = function (newLocale) {\n  if (newLocale) this.currentLocale = newLocale;\n  return this.currentLocale;\n};\n\n// ### polyglot.extend(phrases)\n//\n// Use `extend` to tell Polyglot how to translate a given key.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The key can be any string.  Feel free to call `extend` multiple times;\n// it will override any phrases with the same key, but leave existing phrases\n// untouched.\n//\n// It is also possible to pass nested phrase objects, which get flattened\n// into an object with the nested keys concatenated using dot notation.\n//\n//     polyglot.extend({\n//       \"nav\": {\n//         \"hello\": \"Hello\",\n//         \"hello_name\": \"Hello, %{name}\",\n//         \"sidebar\": {\n//           \"welcome\": \"Welcome\"\n//         }\n//       }\n//     });\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}',\n//     //   'nav.sidebar.welcome': 'Welcome'\n//     // }\n//\n// `extend` accepts an optional second argument, `prefix`, which can be used\n// to prefix every key in the phrases object with some string, using dot\n// notation.\n//\n//     polyglot.extend({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     }, \"nav\");\n//\n//     console.log(polyglot.phrases);\n//     // {\n//     //   'nav.hello': 'Hello',\n//     //   'nav.hello_name': 'Hello, %{name}'\n//     // }\n//\n// This feature is used internally to support nested phrase objects.\nPolyglot.prototype.extend = function (morePhrases, prefix) {\n  forEach(entries(morePhrases || {}), function (entry) {\n    var key = entry[0];\n    var phrase = entry[1];\n    var prefixedKey = prefix ? prefix + '.' + key : key;\n    if (typeof phrase === 'object') {\n      this.extend(phrase, prefixedKey);\n    } else {\n      this.phrases[prefixedKey] = phrase;\n    }\n  }, this);\n};\n\n// ### polyglot.unset(phrases)\n// Use `unset` to selectively remove keys from a polyglot instance.\n//\n//     polyglot.unset(\"some_key\");\n//     polyglot.unset({\n//       \"hello\": \"Hello\",\n//       \"hello_name\": \"Hello, %{name}\"\n//     });\n//\n// The unset method can take either a string (for the key), or an object hash with\n// the keys that you would like to unset.\nPolyglot.prototype.unset = function (morePhrases, prefix) {\n  if (typeof morePhrases === 'string') {\n    delete this.phrases[morePhrases];\n  } else {\n    forEach(entries(morePhrases || {}), function (entry) {\n      var key = entry[0];\n      var phrase = entry[1];\n      var prefixedKey = prefix ? prefix + '.' + key : key;\n      if (typeof phrase === 'object') {\n        this.unset(phrase, prefixedKey);\n      } else {\n        delete this.phrases[prefixedKey];\n      }\n    }, this);\n  }\n};\n\n// ### polyglot.clear()\n//\n// Clears all phrases. Useful for special cases, such as freeing\n// up memory if you have lots of phrases but no longer need to\n// perform any translation. Also used internally by `replace`.\nPolyglot.prototype.clear = function () {\n  this.phrases = {};\n};\n\n// ### polyglot.replace(phrases)\n//\n// Completely replace the existing phrases with a new set of phrases.\n// Normally, just use `extend` to add more phrases, but under certain\n// circumstances, you may want to make sure no old phrases are lying around.\nPolyglot.prototype.replace = function (newPhrases) {\n  this.clear();\n  this.extend(newPhrases);\n};\n\n// ### polyglot.t(key, options)\n//\n// The most-used method. Provide a key, and `t` will return the\n// phrase.\n//\n//     polyglot.t(\"hello\");\n//     => \"Hello\"\n//\n// The phrase value is provided first by a call to `polyglot.extend()` or\n// `polyglot.replace()`.\n//\n// Pass in an object as the second argument to perform interpolation.\n//\n//     polyglot.t(\"hello_name\", {name: \"Spike\"});\n//     => \"Hello, Spike\"\n//\n// If you like, you can provide a default value in case the phrase is missing.\n// Use the special option key \"_\" to specify a default.\n//\n//     polyglot.t(\"i_like_to_write_in_language\", {\n//       _: \"I like to write in %{language}.\",\n//       language: \"JavaScript\"\n//     });\n//     => \"I like to write in JavaScript.\"\n//\nPolyglot.prototype.t = function (key, options) {\n  var phrase, result;\n  var opts = options == null ? {} : options;\n  if (typeof this.phrases[key] === 'string') {\n    phrase = this.phrases[key];\n  } else if (typeof opts._ === 'string') {\n    phrase = opts._;\n  } else if (this.onMissingKey) {\n    var onMissingKey = this.onMissingKey;\n    result = onMissingKey(key, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  } else {\n    this.warn('Missing translation for key: \"' + key + '\"');\n    result = key;\n  }\n  if (typeof phrase === 'string') {\n    result = transformPhrase(phrase, opts, this.currentLocale, this.tokenRegex, this.pluralRules);\n  }\n  return result;\n};\n\n// ### polyglot.has(key)\n//\n// Check if polyglot has a translation for given key\nPolyglot.prototype.has = function (key) {\n  return has(this.phrases, key);\n};\n\n// export transformPhrase\nPolyglot.transformPhrase = function transform(phrase, substitutions, locale) {\n  return transformPhrase(phrase, substitutions, locale);\n};\n\nmodule.exports = Polyglot;\n"]},"metadata":{},"sourceType":"script"}